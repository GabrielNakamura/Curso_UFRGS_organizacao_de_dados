---
title: "Comandos básicos do Git"
author: "Gabriel Nakamura"
date: "5/19/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Em cima, em baixo, *Push* e vai

Abre o computador, trabalha, modifica arquivo, salva o arquivo com um nome diferente do anterior, salva e atualiza a nuvem. Basicamente é isso que fazemos todos os dias, independente se você trabalha com taxonomia de bactérias ou com métodos quantitativos para taxonomia de bactérias. Basicamente, essa é a rotina de quem trabalha na frente do computador. 

Todos esses passos são reproduzidos pelo Git de uma maneira muito mais eficiente, e ela pode ser resumida através dessas palavras: pull, diff, commit, push. Pronto, está completo o ciclo básico de operações necessárias para o controle eficiente de versões do seu projeto.

Apesar dessas ações apresentarem nomes próprios dentro do mundo do versionamento, quero que vejam que elas são bastante familiares, ou seja, fazemos operações de controle de versões quase todos os dias, porém de uma maneira menos eficiente e com menor controle. A grande diferença do uso de um sistema próprio de controle de versão, como o Git, é que ele permite que todos os passos destacados acima estejam sob o nosso controle, de maneira sistematizada e organizada. Em resumo, o Git não deixará você fazer nada que leve a uma cadeia de ações que leve o seu projeto ao caos como o dessa pasta, velha conhecida nossa, e que agora está fadada a ficar no passado: 

![Um diretório fadado a ficar no passado.](/Users/gabrielnakamura/OneDrive/Aulas/Disciplina_ppgEco/Curso_UFRGS_organizacao_de_dados/repo_trash.png)




Cada vez que um arquivo dentro de uma pasta observada pelo Git é modificada ele irá aparecer na aba *Git* do seu RStudio. Esse arquivo precisa ser "stagged", para que o *commit* possa ser feito, e então possamos fazer o *push*. Essa frase pode parecer estranha em um primeiro momento, mas traduzindo. Primeiro precisamos selecionar o arquivo (stage), nomear ele com uma indicação do que foi modificado em relação a versão anterior (commit) e então sincronizá-lo com o repositório remoto (push).

Todas essas funções podem ser feitas através do RStudio, mas também podemos fazer através da linha de comando (também com o RStudio através da aba *Terminal*).

## A via sacra do versionamento

Precisamos aprender, basicamente, três funções básicas do Git para que possamos realizar o controle de versões em nossas pastas, que nesse momento devem estar bem organizadas. São elas:

1 - **Pull** atualiza o seu repositório local com o que tem no seu repositório remoto (GitHub), ou seja, sincronizasua a pasta presente no seu computador com tudo que tem na nuvem;

2 - **Stage** ao selecionarmos os arquivos que fizemos as modificações devem ser olhados com cautela no nosso GitClient (RStudio), para que possasmos verificar as diferenças (diffs na linguagem do versionamento) entre a versão anterior e a atual, após as modificações realizadas;

3 - **Commit** qualquer mudança realizada em qualquer arquivo, desde a menor vírgula até a mudança completa de seu repositório, deve ser acompanhada de um comentário breve destacando o que foi modificado, isso é o commit. Em outras palavras, é uma mensagem de texto para você mesmo, ou seus colaboradores, destacando o que foi modificado no repositório local observado pelo Git. O ideal é que o commit seja uma mensagem informativa e curta, não ultrapassando 40 palavras;

4 - **Push** as modificações realizadas em seus arquivos estão só na sua máquina, ou seja, o repositório remoto (seu GitHub) está desatualizado. Para atualizá-lo devemos fazer um *push*, que nada mais é que sincronizar o repositório local com o repositório remoto.

Esta é a sequência básica para que possamos realizar um versionamento eficiente em nosso projeto. De certa forma a sequência é simples, e toda ela pode ser feita usando os recursos da interface que o RStudio nos oferece. Porém, alguns probleminhas podem surgir no meio dessas etapas descritas, por exemplo: 

## Fiz um commit, mas não deveria

O Git nos permite voltar no tempo de uma maneira muito eficiente, basta acessarmos a 
## Voltando no tempo


## Ignorando caminhos - o .gitignore

[Referência](http://git-scm.com/docs/gitignore)

## Arquivos grandes - Git LFS

[Referência](https://qifengzhou.github.io/2018/04/29/Upload%20files%20bigger%20than%2025%20MB%20to%20Github/)



**Em construção**

